package binarySearch;

class VersionControl {
	boolean isBadVersion(int version) {
		if(version==5||version==6)
			return true;
		return false;
	}
}
public class FirstBadVersion extends VersionControl{

	public static void main(String[] args) {
		FirstBadVersion fbv = new FirstBadVersion();
		System.out.println(fbv.firstBadVersion(6));
	}


	public int firstBadVersion(int n) {
		int low = 1;
		int high = n;
		int pos = -1;
		while(low<=high) {
			int mid = low + (high-low)/2;
			if(isBadVersion(mid)){
				pos = mid;
				high = mid-1;
			} else {
				low = mid + 1;
			}
		}
		return pos;

	}
		/*
		case 1: if the middle version is bad, try to find the previous bad version. Make high as mid-1
		Case 2: if the middle version is not a bad version
					i- if version of highest element is bad or not, if not then return -1.. all the versions are good
					Above case is invalid as atleast the last version wil be bad in input
					ii- there may exist a bad version, low as low+1, search for bad version
					1,2,3,4,5
		 */

		private int binarySearch(int low, int high, int pos) {
			int mid = 0;
			if(low>high){
				return pos;
			} else {
				mid = (low + high)/2;
				 if(isBadVersion(mid)) {
					 pos = mid;
					return binarySearch(low,mid-1,pos);
				} else {
					return binarySearch(mid+1,high,pos);
				}
			}
		}
}
